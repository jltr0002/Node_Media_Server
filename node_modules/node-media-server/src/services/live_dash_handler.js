const { spawn } = require('child_process');
const path = require('path');
const fs = require('fs');
const processRegistry = require('../utils/processRegistry.js');

/**
 * Starts the DASH conversion for the given stream.
 *
 * @param {object} streamInfo - Information about the stream (e.g., name, url).
 */
function handleLiveDashStream(streamInfo) {
  console.log(`Starting DASH conversion for stream: ${streamInfo.name}`);

  const outputDir = path.join(__dirname, '../../../../streams', streamInfo.name);
  const mpdFile = path.join(outputDir, `${streamInfo.name}.mpd`);

  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  const ffmpegArgs = buildFfmpegArgs(streamInfo.url, mpdFile);

  console.log('Running FFmpeg command: ffmpeg ' + ffmpegArgs.join(' '));

  const ffmpegProcess = spawn('ffmpeg', ffmpegArgs, { cwd: outputDir });

  ffmpegProcess.stdout.on('data', (data) => {
    console.log(`FFmpeg stdout: ${data}`);
  });

  ffmpegProcess.stderr.on('data', (data) => {
    console.error(`FFmpeg stderr: ${data}`);
  });

  ffmpegProcess.on('close', (code) => {
    console.log(`FFmpeg process exited with code ${code}`);
    cleanupStreamFiles(outputDir);
    processRegistry.removeProcess(streamInfo.name);
  });

  ffmpegProcess.on('error', (err) => {
    console.error(`FFmpeg failed for ${streamInfo.name}:`, err);
    cleanupStreamFiles(outputDir);
    processRegistry.removeProcess(streamInfo.name);
  });

  processRegistry.addProcess(streamInfo.name, ffmpegProcess);
}

/**
 * Builds the FFmpeg argument list for the given input URL and output MPD file.
 *
 * @param {string} inputUrl - Stream input URL.
 * @param {string} outputMpd - Path to output MPD file.
 * @returns {string[]} List of FFmpeg arguments.
 */
function buildFfmpegArgs(inputUrl, outputMpd) {
  return [
    '-y',
    '-i', inputUrl,
    '-filter_complex',
      "[0:v]split=4[v0][v1][v2][v3];" +
      "[v1]scale=-2:720[v1out];" +
      "[v2]scale=-2:360[v2out];" +
      "[v3]scale=-2:160[v3out]",
    '-map', '0:a', '-c:a', 'aac', '-b:a', '128k',
    '-map', '[v0]', '-c:v:0', 'libx264', '-b:v:0', '4500k', '-maxrate:v:0', '5000k', '-bufsize:v:0', '10000k',
    '-map', '[v1out]', '-c:v:1', 'libx264', '-b:v:1', '2500k', '-maxrate:v:1', '3000k', '-bufsize:v:1', '6000k',
    '-map', '[v2out]', '-c:v:2', 'libx264', '-b:v:2', '1200k', '-maxrate:v:2', '1500k', '-bufsize:v:2', '3000k',
    '-map', '[v3out]', '-c:v:3', 'libx264', '-b:v:3', '600k', '-maxrate:v:3', '800k', '-bufsize:v:3', '1500k',
    '-f', 'dash',
    '-seg_duration', '2',
    '-frag_duration', '2',
    '-use_template', '1',
    '-use_timeline', '1',
    '-adaptation_sets', 'id=0,streams=v id=1,streams=a',
    '-init_seg_name', 'init_$RepresentationID$.mp4',
    '-media_seg_name', 'chunk_$RepresentationID$_$Number%05d$.m4s',
    outputMpd
  ];
}

/**
 * Deletes all files in the stream's output directory.
 *
 * @param {string} dirPath - Path to the stream's directory.
 */
function cleanupStreamFiles(dirPath) {
  if (fs.existsSync(dirPath)) {
    fs.rmSync(dirPath, { recursive: true, force: true });
    console.log(`Cleaned up stream files in ${dirPath}`);
  }
}

module.exports = {
  handleLiveDashStream,
};
