const { spawn, exec } = require('child_process');
const path = require('path');
const fs = require('fs');
const processRegistry = require('../utils/processRegistry.js');

/**
 * Starts the DASH conversion for the given stream.
 *
 * @param {object} streamInfo - Information about the stream (e.g., name, url).
 */
function handleLiveDashStream(streamInfo) {
  console.log(`Starting DASH conversion for stream: ${streamInfo.name}`);

  const outputDir = path.join(__dirname, '../../../../streams', streamInfo.name);

  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  const ffmpegArgs = buildFfmpegArgs(streamInfo.url, outputDir);

  console.log('Running FFmpeg command: ffmpeg ' + ffmpegArgs.join(' '));

  const ffmpegProcess = spawn('ffmpeg', ffmpegArgs, { cwd: outputDir, shell: true });

  ffmpegProcess.stdout.on('data', (data) => {
    console.log(`FFmpeg stdout: ${data}`);
  });

  ffmpegProcess.stderr.on('data', (data) => {
    console.error(`FFmpeg stderr: ${data}`);
  });

  ffmpegProcess.on('close', (code) => {
    console.log(`FFmpeg process exited with code ${code}`);

    if (code === 0) {
      console.log(`FFmpeg finished transcoding, starting Shaka Packager...`);
      packageWithShaka(outputDir, streamInfo.name);
    } else {
      console.warn(`FFmpeg exited with error code ${code}, skipping packaging.`);
      cleanupStreamFiles(outputDir);
      processRegistry.removeProcess(streamInfo.name);
    }
  });

  ffmpegProcess.on('error', (err) => {
    console.error(`FFmpeg failed for ${streamInfo.name}:`, err);
    cleanupStreamFiles(outputDir);
    processRegistry.removeProcess(streamInfo.name);
  });

  processRegistry.addProcess(streamInfo.name, ffmpegProcess);
}

/**
 * Builds the FFmpeg argument list for the given input URL and output directory.
 *
 * @param {string} inputUrl - Stream input URL.
 * @param {string} outputDir - Path to output folder.
 * @returns {string[]} List of FFmpeg arguments.
 */
function buildFfmpegArgs(inputUrl, outputDir) {
  return [
    '-y',
    '-i', inputUrl,
    '-filter_complex',
      "[0:v]split=3[vid1][vid2][vid3];" +
      "[vid2]scale=-2:480[vid2out];" +
      "[vid3]scale=-2:144[vid3out]",
    '-map', '0:a?', '-c:a', 'aac', '-b:a', '128k',
    '-map', '[vid1]', '-c:v:0', 'libx264', '-b:v:0', '4500k',
    '-map', '[vid2out]', '-c:v:1', 'libx264', '-b:v:1', '1500k',
    '-map', '[vid3out]', '-c:v:2', 'libx264', '-b:v:2', '300k',
    '-preset', 'veryfast',
    '-g', '60', '-keyint_min', '60', '-sc_threshold', '0',
    '-movflags', '+frag_keyframe+empty_moov',
    '-f', 'segment', '-segment_time', '2', '-segment_format', 'mp4',
    path.join(outputDir, 'stream_%v_%03d.mp4')
  ];
}


/**
 * Calls Shaka Packager to package the generated segments into a DASH manifest.
 *
 * @param {string} outputDir - Path where the mp4 segments are stored.
 * @param {string} streamName - Name of the stream (for MPD filename).
 */
function packageWithShaka(outputDir, streamName) {
  const packagerCmd = `
    packager ^
      input=${path.join(outputDir, 'stream_0_000.mp4')},stream=video,init_segment=${path.join(outputDir, 'init-original.mp4')},segment_template=${path.join(outputDir, 'seg-original-$Number$.m4s')} ^
      input=${path.join(outputDir, 'stream_1_000.mp4')},stream=video,init_segment=${path.join(outputDir, 'init-480p.mp4')},segment_template=${path.join(outputDir, 'seg-480p-$Number$.m4s')} ^
      input=${path.join(outputDir, 'stream_2_000.mp4')},stream=video,init_segment=${path.join(outputDir, 'init-140p.mp4')},segment_template=${path.join(outputDir, 'seg-140p-$Number$.m4s')} ^
      --profile live ^
      --mpd_output ${path.join(outputDir, `${streamName}.mpd`)}
  `;

  console.log('Running Shaka Packager...');

  exec(packagerCmd, { shell: true }, (error, stdout, stderr) => {
    if (error) {
      console.error('Shaka Packager error:', error);
      cleanupStreamFiles(outputDir);
      return;
    }
    console.log('Shaka Packager finished successfully.');
    console.log('stdout:', stdout);
    console.error('stderr:', stderr);
  });
}


/**
 * Deletes all files in the stream's output directory.
 *
 * @param {string} dirPath - Path to the stream's directory.
 */
function cleanupStreamFiles(dirPath) {
  if (fs.existsSync(dirPath)) {
    fs.rmSync(dirPath, { recursive: true, force: true });
    console.log(`Cleaned up stream files in ${dirPath}`);
  }
}

module.exports = {
  handleLiveDashStream,
};
