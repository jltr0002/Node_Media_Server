// rtmp_session.js
// @ts-check
//
//  Created by Chen Mingliang on 24/11/30.
//  illuspas@msn.com
//  Copyright (c) 2024 Nodemedia. All rights reserved.

const net = require("net");
const path = require("path");
const fs = require("fs");
const { spawn } = require("child_process");
const Rtmp = require("../protocol/rtmp.js");
const Flv = require("../protocol/flv.js");
const logger = require("../core/logger.js");
const Context = require("../core/context.js");
const AVPacket = require("../core/avpacket.js");
const BaseSession = require("./base_session.js");
const BroadcastServer = require("../server/broadcast_server.js");
const querystring = require("node:querystring");

/**
 * @class
 * @augments BaseSession
 */
class RtmpSession extends BaseSession {
  /**
   * @param {Context} ctx 
   * @param {net.Socket} socket 
   */
  constructor(ctx, socket) {
    super();
    this.ctx = ctx;
    this.socket = socket;
    this.ip = socket.remoteAddress + ":" + socket.remotePort;
    this.protocol = "rtmp";
    this.rtmp = new Rtmp();
    this.broadcast = new BroadcastServer();
    
    // For recording purposes
    this.fileStream = null;
    this.rawFlvPath = null;
    this.finalMp4Path = null;
  }

  run = () => {
    this.rtmp.onConnectCallback = this.onConnect;
    this.rtmp.onPlayCallback = this.onPlay;
    // Use onPublish to handle the publish command.
    this.rtmp.onPushCallback = this.onPublish;
    this.rtmp.onOutputCallback = this.onOutput;
    this.rtmp.onPacketCallback = this.onPacket;
    this.socket.on("data", this.onData);
    this.socket.on("close", this.onClose);
    this.socket.on("error", this.onError);
  };

  /**
   * Called when a "connect" command is received.
   * @param {object} req - Expected to contain a cmdObj with the app name.
   */
  onConnect = (req) => {
    if (req && req.cmdObj) {
      this.streamApp = req.cmdObj.app || "live";
    } else {
      this.streamApp = "live";
    }
    logger.info(`RTMP session ${this.id} connected with app: ${this.streamApp}`);
    // Note: the stream name is not provided in the connect command.
  };

  /**
   * Called when a "publish" command is received.
   * @param {object} req - Expected to contain the streamName and possibly host/query.
   */
  onPublish = (req) => {
    if (!req) {
      logger.error(`RTMP session ${this.id} received an undefined publish command. Using default values.`);
      req = {}; // fallback to an empty object
    }
    // Optionally log the received publish message for debugging:
    logger.debug(`Publish command received: ${JSON.stringify(req)}`);
    
    // Use default values if missing
    this.streamApp = (req.cmdObj && req.cmdObj.app) || "live";
    this.streamName = req.streamName || "default";
    this.streamPath = "/" + this.streamApp + "/" + this.streamName;
    this.streamHost = req.host || "";
    this.streamQuery = req.query || {};
  
    // Setup the broadcast for this stream.
    this.broadcast = this.ctx.broadcasts.get(this.streamPath) ?? new BroadcastServer();
    this.ctx.broadcasts.set(this.streamPath, this.broadcast);
    
    // Continue with recording setup.
    logger.info(`RTMP session ${this.id} ${this.ip} start publish ${this.streamPath}`);
    this.isPublisher = true;
    
    // Create folder structure for recordings: recordings/<app>/<streamName>
    const recordingsDir = path.join(__dirname, "..", "recordings", this.streamApp, this.streamName);
    fs.mkdirSync(recordingsDir, { recursive: true });
    
    // Create a temporary FLV file to record the raw data
    this.rawFlvPath = path.join(recordingsDir, `${Date.now()}.flv`);
    // Define the final MP4 file name (adjust as needed)
    this.finalMp4Path = path.join(recordingsDir, `${Date.now()}_final.mp4`);
    
    logger.info(`Recording RTMP stream to temporary FLV file: ${this.rawFlvPath}`);
    this.fileStream = fs.createWriteStream(this.rawFlvPath);
    
    // Write a valid FLV header to the file (assumes Flv.createHeader(true, true) returns one)
    const flvHeader = Flv.createHeader(true, true);
    this.fileStream.write(flvHeader);
    
    const err = this.broadcast.postPush(this);
    if (err != null) {
      logger.error(`RTMP session ${this.id} ${this.ip} publish ${this.streamPath} error, ${err}`);
      this.socket.end();
    }
  };

  onPlay = () => {
    logger.info(`RTMP session ${this.id} ${this.ip} start play ${this.streamPath}`);
    this.isPublisher = false;
    this.broadcast.postPlay(this);
  };

  /**
   * Writes output buffers to the socket.
   * @param {Buffer} buffer 
   */
  onOutput = (buffer) => {
    this.socket.write(buffer);
  };

  /**
   * Called for every parsed RTMP packet.
   * Broadcasts the packet and writes it to the recording file.
   * @param {AVPacket} packet 
   */
  onPacket = (packet) => {
    // Broadcast the packet to subscribers.
    this.broadcast.broadcastMessage(packet);
    
    // Also write the FLV tag (converted from the RTMP packet) to disk.
    if (this.fileStream) {
      const flvMessage = Flv.createMessage(packet);
      this.fileStream.write(flvMessage);
    }
  };

  /**
   * Called when data is received on the socket.
   * @param {Buffer} data 
   */
  onData = (data) => {
    let err = this.rtmp.parserData(data);
    if (err != null) {
      logger.error(`RTMP session ${this.id} ${this.ip} parserData error, ${err}`);
      this.socket.end();
    }
  };

  /**
   * Called when the socket is closed.
   */
  onClose = () => {
    logger.info(`RTMP session ${this.id} close`);
    if (this.isPublisher) {
      if (this.fileStream) {
        // Ensure the file is finished writing before converting.
        this.fileStream.end(() => {
          this.convertFlvToMp4();
        });
      }
      this.broadcast.donePush(this);
    } else {
      this.broadcast.donePlay(this);
    }
  };

  /**
   * Spawns an ffmpeg process to convert the recorded FLV file to MP4.
   */
  convertFlvToMp4 = () => {
    if (!this.rawFlvPath || !this.finalMp4Path) {
      logger.error("Recording file paths not set, skipping conversion.");
      return;
    }
    logger.info(`Starting ffmpeg conversion from ${this.rawFlvPath} to ${this.finalMp4Path}`);
    
    const ffmpegArgs = [
      '-y',               // Overwrite output if exists
      '-i', this.rawFlvPath,
      '-c', 'copy',       // Copy codecs (no re-encoding)
      this.finalMp4Path
    ];
    
    const ffmpegProcess = spawn('ffmpeg', ffmpegArgs);
    
    ffmpegProcess.stdout.on('data', (data) => {
      logger.info(`ffmpeg stdout: ${data}`);
    });
    
    ffmpegProcess.stderr.on('data', (data) => {
      logger.info(`ffmpeg stderr: ${data}`);
    });
    
    ffmpegProcess.on('close', (code) => {
      if (code === 0) {
        logger.info(`ffmpeg conversion successful: ${this.finalMp4Path}`);
        // Optionally, delete the temporary FLV file.
        fs.unlink(this.rawFlvPath, (err) => {
          if (err) {
            logger.error(`Error deleting temporary file ${this.rawFlvPath}: ${err}`);
          } else {
            logger.info(`Deleted temporary file ${this.rawFlvPath}`);
          }
        });
      } else {
        logger.error(`ffmpeg process exited with code ${code}`);
      }
    });
  };

  /**
   * Called on socket error.
   * @param {Error} error 
   */
  onError = (error) => {
    logger.info(`RTMP session ${this.id} socket error, ${error.name}: ${error.message}`);
  };

  /**
   * Sends a buffer to the socket.
   * @param {Buffer} buffer
   */
  sendBuffer = (buffer) => {
    this.socket.write(buffer);
  };
}

module.exports = RtmpSession;
